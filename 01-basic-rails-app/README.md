# This tutorial covers

- Dockerize a Rails 5 app with Postgres
- Deploying the app to a running kubernetes cluster
- Connecting to externally configured Database (using Amazon RDS)
- `rake db:migrate`

## Kubernetes concepts:

- Pods
- Deployments
- Services (specifically ELB-backed ones)
- Secrets

## Not covered (but probably of interest):

- asset precompile w/ nginx serving static assets, See example: *TODO*
- exposing your app by domain-prefix (using built-in `nginx-ingress`), See example: *TODO*
- Connecting to a Database running on another container inside kubernetes, See example: *TODO*
- Using kubernetes manifest files (yaml configuration files) to create deployments, services, etc...
- Scaling up and down
- Deploying without downtime
- Readyness checks vs liveness checks
- Termination grace period: https://pracucci.com/graceful-shutdown-of-kubernetes-pods.html
- background tasks (e.g. resque) and reusing the same container
- using tagging for a green-blue deploy

# Step by Step

## 1. `rails new`

    rails new pg-rails

We'll be using postgres as the database and unicorn as the app server, so make sure they are in your Gemfile (`vi Gemfile`):

    gem 'pg'
    gem 'unicorn'

Now do something that would require a database, and respond on "/". (Be creative, or copy directly from this example).

like a model:

    bundle exec rails generate model HitCounter hits:integer
    cp ~/kubernetes-workshop/01-basic-rails-app/snippets/hit_counter.rb app/models/hit_counter.rb

and a controller:

    bundle exec rails generate controller Slash
    cp ~/kubernetes-workshop/01-basic-rails-app/snippets/slash_controller.rb app/controllers/slash_controller.rb

and a route:

    cp ~/kubernetes-workshop/01-basic-rails-app/snippets/routes.rb config/routes.rb

Customize the JSON output of `slash_controller.rb` to be sure it's YOUR app that's being run and not the `jacobo/myapp` image generated by the tutorial authors.

    vi app/controllers/slash_controller.rb

    ...
    render json: {"Hit Count" => HitCounter.hits, "Owner" => "Leowen"}
    ...

## 1.5 Test run with unicorn (optional)

You should be able to run your app locally with:

    bundle
    bundle exec rake db:migrate
    bundle exec unicorn -p 5000

If you were doing this on your local dev machine you'd pop open a browser and visit localhost:5000,
but since you are doing this on the "bridge" box you'll need to point your browser at the amazon public hostname plus port 5000.

NOTE: the clusters setup for this workshop have been intentionally "opened-up" to have all ports open to the world so we can debug and inspect, but this is not recommended for production.

## 2. Dockerfile

Our app will run inside a container, so we need a Dockerfile that defines how to setup it's OS-level dependencies and ends with what command to run (`bundle exec unicorn`)

    vi Dockerfile

Here's a basic one:

    #The base image, with ruby pre-installed
    #see: https://hub.docker.com/_/ruby/
    FROM ruby:2.3

    # Install dependencies:
    # - build-essential: To ensure certain gems can be compiled
    # - nodejs: Compile assets
    # - libpq-dev: Communicate with postgres through the postgres gem
    # - postgresql-client-9.4: In case you want to talk directly to postgres
    RUN apt-get update && apt-get install -qq -y build-essential nodejs libpq-dev postgresql-client-9.4 --fix-missing --no-install-recommends

    # Set an environment variable to store where the app is installed to inside
    # of the Docker image.
    ENV INSTALL_PATH /app
    RUN mkdir -p $INSTALL_PATH

    # This sets the context of where commands will be ran in and is documented
    # on Docker's website extensively.
    WORKDIR $INSTALL_PATH

    # Ensure gems are cached and only get updated when they change. This will
    # drastically increase build times when your gems do not change.
    COPY Gemfile Gemfile
    RUN bundle install

    # Copy code from working directory outside Docker to working directory inside Docker
    COPY . .
    #This extra bundle call is needed to install unicorn-related binaries / native extensions
    RUN bundle

    # The default command to start the Unicorn server.
    CMD bundle exec unicorn -p 5000

Next we'll build the docker image for your app.

**IMPORTANT** This is the step where you want to make sure you are not consuming conference bandwidth. If you have been developing you app locally and not the "bridge" box, now is the time to push it up there. Building and pushing docker images consumes significant bandwidth, but if we do it while SSH'd into our "bridge" box we're consuming bandwith on Amazon EC2 instead of locally.

Connect Docker daemon to docker hub using the `login` command:

    sudo docker login

Replace `jacobo` in these next few commands with your account name on Docker hub (hub.docker.com), and `myapp` with the name of your rails app.

Build a docker image and tag it:

    sudo docker build -t jacobo/myapp .

Push the tagged image to docker hub:

    sudo docker push jacobo/myapp

## 2.5 Test run with docker (optional)

You should be able to run your app locally inside docker with:

    sudo docker run -d -p 5000:5000 jacobo/myapp

Needs to be torn-down, for example:

    $ sudo docker ps
    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
    929f6f34b1a1        jacobo/myapp        "/bin/sh -c 'bundle e"   2 minutes ago       Up 2 minutes        0.0.0.0:5000->5000/tcp   romantic_volhard

    $ sudo docker kill 929f6f34b1a1

## 3 Deploy on Kubernetes

Create a deployment:

    kubectl run myapp --image=jacobo/myapp --port 5000

See it running, e.g.:

    $ k get pods -o wide
    NAME                              READY     STATUS             RESTARTS   AGE       IP            NODE
    myapp-2127871177-683h5            1/1       Running            0          29s       10.200.1.11   ip-172-20-4-152.ec2.internal

Curl to fetch it from any node in the cluster:

    curl -v 10.200.1.11:5000

But it's still not exposed external to the cluster.

Expose external to the cluster by creating a Load Balancer:

    kubectl expose deployment myapp --type=LoadBalancer --name=myapp --port=80 --target-port=5000

e.g:

    $ k get services -o wide
    NAME             CLUSTER-IP      EXTERNAL-IP                                                               PORT(S)        AGE       SELECTOR
    kubernetes       10.254.0.1      <none>                                                                    443/TCP        6d        <none>
    myapp            10.254.55.72    ae036ae591e7611e782cc0add41e3562-1667221753.us-east-1.elb.amazonaws.com   80:32237/TCP   8s        run=myapp

then visit (takes about 5 minutes to provision the Elastic Load Balancer):

    ae036ae591e7611e782cc0add41e3562-1667221753.us-east-1.elb.amazonaws.com

## 4 Connecting to a "real" database (and going to "production")

So far we've been using sqlite. If we kill the running pod, and let the deployment recreate it, the hit counter will start over back where it was when we built the docker image.

    $ seq 5 | xargs -I{} curl ae036ae591e7611e782cc0add41e3562-1667221753.us-east-1.elb.amazonaws.com
    {"Hit Count":32}{"Hit Count":33}{"Hit Count":34}{"Hit Count":35}{"Hit Count":36}

    $ k get pods
    NAME                              READY     STATUS             RESTARTS   AGE
    myapp-2127871177-pzjld            1/1       Running            0          55s

    $ k delete pods/myapp-2127871177-pzjld
    pod "myapp-2127871177-pzjld" deleted

    $ k get pods
    NAME                              READY     STATUS             RESTARTS   AGE
    myapp-2127871177-m0642            1/1       Running            0          2s
    myapp-2127871177-pzjld            1/1       Terminating        0          1m

    $ seq 5 | xargs -I{} curl ae036ae591e7611e782cc0add41e3562-1667221753.us-east-1.elb.amazonaws.com
    {"Hit Count":6}{"Hit Count":7}{"Hit Count":8}{"Hit Count":9}{"Hit Count":10}

We're also still running in development mode.

    $ k get pods
    NAME                              READY     STATUS             RESTARTS   AGE
    myapp-2127871177-m0642            1/1       Running            0          7m

    $ k exec -it myapp-2127871177-m0642 bash
    root@myapp-2127871177-m0642:/app# bundle exec rails c
    Running via Spring preloader in process 46
    Loading development environment (Rails 5.0.2)
    irb(main):001:0> Rails.env
    => "development"

### environment variables

The kubernetes `deployment` is responsible for ensuring N replicas of our `myapp` pod is running. So we can actually delete and re-create the deployment without downtime if set `--cascade=false`, this will ensure the pods are not deleted.  We'll then re-create it with environment variables.

    $ k get deployments
    NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
    myapp     1         1         1            1           10h

    $ k delete deployments/myapp --cascade=false
    deployment "myapp" deleted
    $ k get pods
    NAME                     READY     STATUS    RESTARTS   AGE
    myapp-2127871177-m0642   1/1       Running   0          51m

    $ kubectl run myapp --image=jacobo/myapp --port 5000 --env="RAILS_ENV=production"

If we load the app in a browser now (via ELB hostname) we should see an error:

    open http://ae036ae591e7611e782cc0add41e3562-1667221753.us-east-1.elb.amazonaws.com/

    Missing `secret_key_base` for 'production' environment, set this value in `config/secrets.yml`

### secrets

Create a SECRET_KEY_BASE secret:

    ruby -rsecurerandom -e "print SecureRandom.base64(100)" > skb
    kubectl create secret generic secret-key-base --from-file=skb
    rm skb

Verify it:

    $ k get secrets
    NAME                  TYPE                                  DATA      AGE
    secret-key-base       Opaque                                1         5s

Attach the secret to the deployment, by editing and replacing the deployment:

    k get deployments/myapp -o json | \
      ruby -rjson -e "puts JSON.pretty_generate(JSON.load(STDIN.read).tap{|x|
        x['spec']['template']['spec']['containers'].first['env'] <<
          {name: 'SECRET_KEY_BASE', valueFrom: {secretKeyRef: {name: 'secret-key-base', key: 'skb'}}}})" | \
            k replace -f -

    $ k get pods
    NAME                    READY     STATUS        RESTARTS   AGE
    myapp-254138870-vmjj1   1/1       Terminating   0          19s
    myapp-596859129-kp76n   1/1       Running       0          14s

    $ k exec -it myapp-596859129-kp76n -- bash
    $ env
    ...
    SECRET_KEY_BASE=yH3dBDn6YTate8FXSyhrntDwMCPitSpv0cLmqCtTF1M...
    ...

Now try the app again:

    open http://ae036ae591e7611e782cc0add41e3562-1667221753.us-east-1.elb.amazonaws.com/

Get a 500 error, but we're in `RAILS_ENV=production` now so it's not so easily visible

We can try:

    k logs myapp-596859129-kp76n

But that only gives us STDOUT of the unicorn process (Which, BTW, you can improve with a config option. see: TODO)
We can also just exec into the pod again and look at the logs:

    k exec -it myapp-596859129-kp76n -- bash
    tail -f log/production.log
    ...
      ActiveRecord::StatementInvalid (SQLite3::SQLException: no such table: hit_counters
    ...

So the database doesn't exist because it's still sqlite and we didn't migrate. Let's switch it to postgres by populating `DATABASE_URL`

In a coming-very-soon version of the Engine Yard CLI: `kubey`, you'll be able to provision RDS databases. In the meantime, you'll have to make use of the one that's already provided.

`k get secrets` should show that there's a `exampledb` secret. We can look at it's contents with a little help from ruby.

`k get secret/exampledb -o yaml` shows a YAML description of the secret with an obfuscated value for `database-url`. But it's only obfuscated with Base64, so to see it's contents:

    k get secret/exampledb -o yaml | ruby -ryaml -rbase64 -e "puts Base64.decode64(YAML.load(STDIN)['data']['database-url'])"

TODO: could we instead use AWS CLI to fetch the root creds of the database master and then create the DB directly with a psql command?

So now let's attach that secret to our cluster as DATABASE_URL

    k get deployments/myapp -o json | \
      ruby -rjson -e "puts JSON.pretty_generate(JSON.load(STDIN.read).tap{|x|
        x['spec']['template']['spec']['containers'].first['env'] <<
          {name: 'DATABASE_URL', valueFrom: {secretKeyRef: {name: 'exampledb', key: 'database-url'}}}})" | \
            k replace -f -

And we need to migrate (TODO: discussion about how we are waiting for k8s to implement deploy hooks)

    $ k get pods
    NAME                     READY     STATUS    RESTARTS   AGE
    myapp-3909670473-7cpz9   1/1       Running   0          1m
    $ k exec -it myapp-3909670473-7cpz9 -- bash
    bundle exec rake db:migrate

And now, finally, it's working, right?

    open http://ae036ae591e7611e782cc0add41e3562-1667221753.us-east-1.elb.amazonaws.com/
